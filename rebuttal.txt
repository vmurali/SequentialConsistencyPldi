Store-atomicity vs weak memory-models:
We define store-atomicity as a property of just the memory-subsystem, which is
quite complex in its own right, with hierarchies of caches.  There are
additional cache-like elements attached to individual processors, called by
names like "store-buffer".  If we consider these extra buffers as part of the
memory, then Reviewer-A is correct in saying the weak memory-models don't
guarantee atomic stores. However, weak-memory systems are built on top of the
same store-atomic main memory interface defined in LTS of Figure-5; it's only
the processor-local buffers that introduce weaker behavior (we address
Reviewer-A's examples at the end). Proving that the cache-LTS (Figure-10)
preserves store-atomicity (Figure-5) is a major contribution of this paper. We
agree, however, that extension to weaker memory-models needs work.

Choice of SC:
We define "sequential-consistency" as the LTS in Figure-3, which completely
specifies the observable behavior of a full multiprocessor system, including
termination. Thus, by proving a relationship with that LTS, we are proving what
is perhaps the most natural version of "full functional correctness" in this
domain.

Main result (Theorem-10):
We apologize for not getting across the sense of the main theorem. A system
with our speculative processors and store-atomic memory actually does fulfill
the SC spec, without any side conditions on programs or hidden assumptions! We
think the proof is nontrivial. We view simplicity of our proof outline as a
feature, not a bug. The actual proof in Coq is about 10000 lines.

Proof reusability:
MOSI, MOESI, etc. are very similar to MSI protocol. The way our proof is
organized, we will have to just prove Lemmas 5, 6, and Invariants 2, 3, 4 for
each of these protocols. These lemmas deal with less than 4 states and thus can
also be proven easily using model-checking.

LTS specifications for hardware:
Sorry for not explaining our rationale for considering LTSes as practical
hardware descriptions.  The cache-LTS (Figure-10), for instance, is a direct
transliteration from Bluespec-code [Khan]. See also [Dave].  We plan on
automating the translation from Bluespec-code, but we think the two
abstractions are close enough that it is reasonable to draw conclusions from
manual translations.

Processor Specification:
The processor-LTS (Figure-7) is intentionally abstract to capture a superset of
microarchitectures; eg, we do not give the actual transitions for a reorder
buffer implementation but instead give its correctness criteria (Figure-8).
Our ISA is abstract enough to include CISC-instructions and if desired can be
extended with atomic-memory-instructions and memory-barriers.

SC performance:
In the architecture literature, it has been shown that an aggressive
speculative implementation of SC (like ours) may perform as well as weaker
memory-models ([Falsafi], [Hill]). These arguments are orthogonal to
this paper's technical contributions.

Termination-property:
Our main theorem uses termination as an arbitrary property which makes the
theorem interesting but still easily stated. That's for the same reason that
many problems in computability-theory are equivalent to halting-problem in
suitable senses.

----------------------- 

Reviewer-C
1. Please note that the buffers between processor and memory-subsystems --
states "ins" and "outs" in Figures 4, 5, 7, 10 -- are multi-capacity buffers.


Reviewer-A
1. Thanks for the bug reports on our related work discussion.

2. Examples:
IRIW behavior:
Consider a system containing several in-order cores, each core connected to
''non-coherent cache'' NCC. All NCCs are connected to a global atomic sotore.
An NCC can read any location from memory and keep it, and the core can load the
location from NCC, if present. But stores from the core always happen to the
global store, and the NCC can discard the location that it has, anytime. 

At the beginning, NCC of core 4 reads in the location for x. The following
sequence gives the required behavior:
Core 1: Wx1 (into global memory)
Core 2: Rx (gets 1 from global memory)
        Ry (gets initial value 0 from global memory)
Core 3: Wy1 (into global memory)
Core 4: Ry (gets 1 from global memory)
        Rx (gets 0 from NCC)

Store buffer behavior:
Instead of NCC, each core has a store-buffer into which stores are written, and
loads can read from. The following sequence gives the required behavior:
Core 1: Wx1 (into store buffer, not to memory)
        Ry (gets initial value 0 from global memory)
Core 2: Wy1 (into store buffer, not to memory)
        Rx (gets initial value 0 from global memory)
--------------------------------------------------

Citations in the rebuttal:

[Falsafi] Guiady, C.; Falsafi, B.; Vijaykumar, T. N., "Is SC+ILP=RC?," Computer
Architecture, 1999. Proceedings of the 26th International Symposium on , vol.,
no., pp.162,171, 1999 doi: 10.1109/ISCA.1999.765948 URL:
http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=765948&isnumber=16584

[Hill] Mark D. Hill. 1998. Multiprocessors Should Support Simple
Memory-Consistency Models. Computer 31, 8 (August 1998), 28-34.
DOI=10.1109/2.707614 http://dx.doi.org/10.1109/2.707614

[Khan] Asif Khan, Muralidaran Vijayaraghavan, Silas Boyd-Wickizer, and Arvind.
2012. Fast and cycle-accurate modeling of a multicore processor. In Proceedings
of the 2012 IEEE International Symposium on Performance Analysis of Systems &
Software (ISPASS '12). IEEE Computer Society, Washington, DC, USA, 178-187.
DOI=10.1109/ISPASS.2012.6189224 http://dx.doi.org/10.1109/ISPASS.2012.6189224

[Dave] N. Dave, M. C. Ng, and Arvind. 2005. Automatic synthesis of
cache-coherence protocol processors using Bluespec. In Proceedings of the 2nd
ACM/IEEE International Conference on Formal Methods and Models for Co-Design
(MEMOCODE '05). IEEE Computer Society, Washington, DC, USA, 25-34.
DOI=10.1109/MEMCOD.2005.1487887 http://dx.doi.org/10.1109/MEMCOD.2005.1487887
